//
// Handle nested
//
$_s_nested_properties : ();
$_s_nested_properties_depth : ();
@function _sugar-handle-nested(
	$name,
	$map
) {
	@if map-get($_s_nested_properties, $name) {
		$map : map-merge(map-get($_s_nested_properties, $name), $map);
	} @else {
		$_s_nested_properties : map-set($_s_nested_properties, $name, $map) !global;
	}
	@return $map;
}
@mixin _sugar-handle-nested(
	$args...
) {
	@each $arg in $args {
		$name : $arg;
		// up depth
		$depth : map-get($_s_nested_properties_depth, $name);
		@if $depth == null or $depth == 0 {
			$depth : 1;
		} @else {
			$depth : $depth + 1;
		}
		
		$_s_nested_properties_depth : map-set($_s_nested_properties_depth, $name, $depth) !global;
	}

	@content;

	@each $arg in $args {
		$name : $arg;
		$reset : false;
		$depth : map-get($_s_nested_properties_depth, $name);
		$depth : $depth - 1;
		$_s_nested_properties_depth : map-set($_s_nested_properties_depth, $name, $depth) !global;
		@if $depth <= 0 {
			$reset : true;
		}
		@if $reset {
			$_s_nested_properties : map-set($_s_nested_properties, $name, null) !global;
		}
	}

	
}

//
// Parse properties
//
@function _sugar-parse-properties(
	$properties,
	$keywords,
	$aliases : ()
) {
	// default aliases
	$aliases : map-merge($aliases, (
		width : 'w',
		height : 'h',
		color : 'c',
		top : 't',
		right : 'r',
		bottom : 'b',
		left : 'l'
	));

	@if $keywords {
		$keywords : map-merge($keywords, (
			restore : true
		));
	}

	$map : ();
	$values : ();
	$current_prop : null;
	$first : true;
	@each $prop in $properties {
		
		@if type-of($prop) == string and str-slice($prop,1,1) == '-' {
			
			// remove the - at property beginning
			$prop : str-slice($prop, 2);

			// check if we have a property named like this in map
			$in_keywords : null;

			@if $keywords {
				$in_keywords : map-get($keywords, $prop);

				// if not in keywords, try to get the alias
				@if $in_keywords == null {
					$alias_found : false;
					@each $alias_prop, $alias in $aliases {
						@if $alias_found == false {
							$split : str-explode($alias,'|');
							$al : index($split, $prop);
							@if $al {
								$alias_found : true;
								$prop : $alias_prop;
							}
						}
					}
					// check again if now we have a property like this
					$in_keywords : map-get($keywords, $prop);
				}
			}

			// if we have a property in map
			@if $in_keywords or $keywords == null {

				// explicit naming
				@if $current_prop {
					@if length($values) == 0 {
						$values : true
					} @else if length($values) == 1 {
						$values : nth($values, 1);
					}
					$map : map-set($map, $current_prop, $values);
				}
				$first : false;
				$current_prop : $prop;
				$values : ();
			}
		} @else {

			@if $first {
				// check if the type is ok
				$found : false;
				@each $name, $type in $keywords {
					@if $found == false {
						@if type-of($type) == string and str-index($type,'|') {
							$parts : str-explode($type,'|');
							@if index($parts, $prop) {
								$map : map-set($map, $name, $prop);
								// remove the item from keywords
								$keywords : map-remove($keywords, $name);
								// stop searching
								$found : true;
							}
						} @else {
							@if type-of($prop) == $type {
								$map : map-set($map, $name, $prop);
								// remove the item from keywords
								$keywords : map-remove($keywords, $name);
								// stop searching
								$found : true;
							}
						}
					}
				}
			} @else {
				$values : append($values, $prop);
			}

			@if $current_prop {
				@if length($values) == 0 {
					$values : true
				} @else if length($values) == 1 {
					$values : nth($values, 1);
				}
				$map : map-set($map, $current_prop, $values);
			}
		}
	}
	@if $current_prop {
		@if length($values) == 0 {
			$values : true
		} @else if length($values) == 1 {
			$values : nth($values, 1);
		}
		$map : map-set($map, $current_prop, $values);
	}

	// return map
	@return $map;
}