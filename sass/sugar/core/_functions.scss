//
// Handle nested
//
$_s_nested_properties : ();
$_s_nested_properties_depth : ();
@function s-handle-nested(
	$name,
	$map
) {
	@if map-get($_s_nested_properties, $name) {
		$map : map-merge(map-get($_s_nested_properties, $name), $map);
	} @else {
		$_s_nested_properties : map-set($_s_nested_properties, $name, $map) !global;
	}
	@return $map;
}
@mixin s-handle-nested(
	$args...
) {
	@each $arg in $args {
		$name : $arg;
		// up depth
		$depth : map-get($_s_nested_properties_depth, $name);
		@if $depth == null or $depth == 0 {
			$depth : 1;
		} @else {
			$depth : $depth + 1;
		}
		
		$_s_nested_properties_depth : map-set($_s_nested_properties_depth, $name, $depth) !global;
	}

	@content;

	@each $arg in $args {
		$name : $arg;
		$reset : false;
		$depth : map-get($_s_nested_properties_depth, $name);
		$depth : $depth - 1;
		$_s_nested_properties_depth : map-set($_s_nested_properties_depth, $name, $depth) !global;
		@if $depth <= 0 {
			$reset : true;
		}
		@if $reset {
			$_s_nested_properties : map-set($_s_nested_properties, $name, null) !global;
		}
	}

	
}

//
// Parse properties
//
@function s-parse-properties(
	$properties,
	$keywords,
	$aliases : ()
) {

	// default aliases
	$aliases : map-merge($aliases, (
		width : w,
		height : h,
		color : c,
		top : t,
		right : r,
		bottom : b,
		left : l
	));

	// check if is a map or a list
	@if type-of($properties) == map {
		$new-map : ();

		// loop on each properties to 
		@each $prop, $value in $properties {

			// get the real name
			$prop : _s-get-property-name($prop, $keywords, $aliases);

			// if we have a property
			@if $prop {

				// get the type
				$type : _s-get-property-type($prop, $keywords, $aliases);

				// if we have found, check the type
				@if $type and not _is-null($value) {

					// check explicit values
					@if type-of($type) == string {
						// check the type
						@if not s-is($value, $type) {
							@error('The property #{$prop} need to be a #{$type} but it seems that you pass a #{type-of($value)} : #{$value}...');
						}
						$new-map : map-set($new-map, $prop, $value);
					} @else if type-of($type) == list {
						// check if the passed value exist in possible values
						@if type-of($value) == list and index($type, length) {
							$new-map : map-set($new-map, $prop, $value);
						} @else if type-of($value) == number and index($type, length) {
							$new-map : map-set($new-map, $prop, $value);
						} @else if index($type, $value) {
							$new-map : map-set($new-map, $prop, $value);
						}
					} @else {
						// we do nothing but adding the value like this
						$new-map : map-set($new-map, $prop, $value);
					}

				} @else if not _is-null($value) {
					// // add the value to map
					// @if not map-get($new-map, others) {
					// 	$new-map : map-set($new-map, others, ());
					// }
					// $new-map : map-set($new-map, others, map-merge(map-get($new-map, others), (
					// 	$prop : $value
					// )));
				}
			}
		}

		// return new map
		@return $new-map;

	} @else {

		$map : ();
		$values : ();
		$current_prop : null;
		$first : true;
		@each $prop in $properties {
			
			@if type-of($prop) == string and str-slice($prop,1,1) == '-' {
				
				// remove the - at property beginning
				$prop : str-slice($prop, 2);

				// get the real name
				$prop : _s-get-property-name($prop, $keywords, $aliases);

				// we have a new property
				// need to check if we have already one in memory
				// to save it in the map after checking the type
				@if $current_prop {
					@if length($values) == 0 {
						$values : true
					} @else if length($values) == 1 and type-of($values) == list {
						$values : nth($values, 1);
					}
					@if $values {
						$type : _s-get-property-type($current_prop, $keywords, $aliases);
						@if s-is($values, $type) {
							$map : map-set($map, $current_prop, $values);
						} @else {
							@error('The property #{$current_prop} need to be a #{$type} but it seems that you passed a #{type-of($values)} : #{$values}...');
						}
					}
				}
				$first : false;
				@if $prop {
					$current_prop : $prop;
					$values : ();
				}
				
				// } @else {
				// 	// we do not have the property in keywords
				// 	// but it is still a property...
				// 	// we have to reset the current prop to null
				// 	// in order to not append values in previous
				// 	// founded property
				// 	$first : false;
				// 	$current_prop : null;
				// 	$values : ();
				// }
			} @else {

				@if $first {
					// check if the type is ok
					$found : false;
					@each $name, $type in $keywords {
						@if $found == false {
							@if s-is($type, list) and index($type, $prop) {
								$keywords-v : nth($type, index($type, $prop));
								$ok : true;
								@if s-is($prop, number) and index($type, length) {
									$ok : true;
								} @else if s-is($prop, number) and unit($prop) != unit($keywords-v) {
									$ok : false;
								}

								@if $ok {
									$map : map-set($map, $name, $prop);
									// remove the item from keywords
									$keywords : map-remove($keywords, $name);
									// stop searching
									$found : true;
								}
							} @else if s-is($type, string) and s-is($prop, $type) {
								$map : map-set($map, $name, $prop);
								// remove the item from keywords
								$keywords : map-remove($keywords, $name);
								// stop searching
								$found : true;
							}
						}
					}
				} @else {
					$values : append($values, $prop);
				}

				@if $current_prop {
					@if length($values) == 0 {
						$values : true
					} @else if length($values) == 1 and type-of($values) == list {
						$values : nth($values, 1);
					}
					@if not _is-null($values) {
						$type : _s-get-property-type($current_prop, $keywords, $aliases);
						@if $type and type-of($type) == string and not s-is($values, $type) {
							@error('The property #{$current_prop} need to be a #{$type} but it seems that you passed a #{type-of($values)} : #{$values}');
						}
						$map : map-set($map, $current_prop, $values);
					}
				}
			}
		}
		@if $current_prop {
			@if length($values) == 0 {
				$values : true
			} @else if length($values) == 1 and type-of($values) == list {
				$values : nth($values, 1);
			}
			@if not _is-null($values) {
				$type : _s-get-property-type($current_prop, $keywords, $aliases);
				@if $type and type-of($type) == string and not s-is($values, $type) {
					@error('The property #{$current_prop} need to be a #{$type} but it seems that you passed a #{type-of($values)} : #{$values}');
				}
				$map : map-set($map, $current_prop, $values);
			}
		}

		// return map
		@return $map;

	}
}

@function _s-get-property-name(
	$property,
	$keywords : (),
	$aliases : ()
) {
	@if not $keywords {
		$keywords : ();
	}
	@if not $aliases {
		$aliases : ();
	}

	// check if exist
	$type : map-get($keywords, $property);
	// if we have a type, mean a property names like this
	// exist, return it
	@if $type {
		@return $property;
	}

	// if not in keywords, try to get the alias
	@if not $type {
		$alias_found : false;
		@each $alias_prop, $alias in $aliases {
			$al : index($alias, $property);
			@if $al {
				@return $alias_prop;
			}
		}
	}

	// nothing found
	@return null;
}

@function _s-get-property-type(
	$property,
	$keywords : (),
	$aliases : ()
) {
	@if not $keywords {
		$keywords : ();
	}
	@if not $aliases {
		$aliases : ();
	}

	// check if exist
	$type : map-get($keywords, $property);

	// if not in keywords, try to get the alias
	@if not $type {
		$alias_found : false;
		@each $alias_prop, $alias in $aliases {
			@if $alias_found == false {
				$al : index($alias, $property);
				@if $al or type-of($alias) == string and $property == $alias {
					$alias_found : true;
					$property : $alias_prop;
				}
			}
		}
		// check again if now we have a property like this
		$type : map-get($keywords, $property);
	}
	// return the type
	@return $type;
}