@mixin s-formset-label(
	$colors : null
) {
	@include s-formset-label-bare();
	@if $colors {
		@include s-formset-label-style($colors);
	}
}

@mixin s-formset-label-bare(
) {
	@include s-formset-init();

	// pass in the component context
	@include s-component-context('formset') {

		.label {
			&, > span {
				user-select: none;
				font-weight: bold;
			}

			// restore font-weight
			.s-radiobox ~ &,
			.label, label,
			> * {
				font-weight: normal;
			}

			// no margin-bottom on nested labels
			.label,
			label {
				margin-bottom: 0 !important;
			}

			@include s-vertical-rhythme {
				#{s-selector((
					BEM : (
						'.input:not([type="checkbox"]):not([type="radio"])',
						'.input-addon',
						'.form-group'
					),
					SMACCS : (
						'.input:not([type="checkbox"]):not([type="radio"])',
						'.input-addon',
						'.form-group'
					)
				))} {
					margin-top: 1rem;
					margin-bottom: 0 !important;
				}
			}
		}

		// span label styling
		#{s-selector((
			BEM : (
				'.label--inline',
				'.label--inside'
			),
			SMACCS : (
				'.label-inline',
				'.label-inside'
			)
		))} {
			> span {
				padding : 0 s-lnf(padding-vertical);
				line-height: 1em + s-lnf(padding-horizontal) * 2;
				height: 1em + s-lnf(padding-horizontal) * 2;
			}
		}

		.label {
			// font-size: 1em;
			display: inline-block;
			vertical-align: middle;
			position: relative;

			&:not(.s-radiobox) {
				@include s-vertical-rhythme {
					margin-bottom: 2em;
				}
				&:first-child:last-child {
					width: 100%;
				}
			}

			& + label,
			& + .label {
				margin-left: s-lnf(padding-vertical);
			}
		}

		// if want the inline style
		#{s-selector((
			BEM : '.label--inline',
			SMACCS : '.label-inline'
		))} {
			display: flex !important;

			> * {
				flex:0;
				margin-top:0 !important;
			}
			> .input {
				flex:1;
			}
			> span {
				flex : 0;
				white-space: nowrap;
				display:inline-block;

				&:first-child {
					padding-left: 0 !important;
				}
				&:last-child {
					padding-right: 0 !important;
				}
			}
		}

		// material
		#{s-selector((
			BEM : '.label--material',
			SMACCS : '.label-material'
		))} {
			> input {
				@include s-transition(fast);
				padding-left:0;
				border-left: none !important;
				border-right: none !important;
				border-top: none !important;
			}
			> span {
				display:inline-block;
				padding: s-lnf(padding-horizontal) s-lnf(padding-vertical);
				padding-left: 0;
				height: 1em + s-lnf(padding-horizontal) * 2;
				position:absolute;
				top:0; left:0;
				white-space: nowrap;
				pointer-events: none;
				text-overflow: ellipsis;
				overflow: hidden;
				@include s-translate(0,0);
				@include s-transition(fast padding, fast font-size);
			}
			> input[value]:not([value=""]) ~ span,
			> input:focus ~ span {
				font-size: 0.7em;
				padding: 0;
			}
			> input[value]:not([value=""]),
			> input:focus {
				padding-left: 0 !important;
				padding-top: s-lnf(padding-horizontal) * 1.33 !important;
				padding-bottom : s-lnf(padding-horizontal) - s-lnf(padding-horizontal) / 3 !important;
			}
		}

		// push
		#{s-selector((
			BEM : '.label--push',
			SMACCS : '.label-push'
		))} {
			> input {
				@include s-transition(fast);
			}
			> span {
				display:inline-block;
				padding: s-lnf(padding-horizontal) s-lnf(padding-vertical);
				height: 1em + s-lnf(padding-horizontal) * 2;
				position:absolute;
				top:0; left:0;
				white-space: nowrap;
				pointer-events: none;
				text-overflow: ellipsis;
				overflow: hidden;
				@include s-translate(0,0);
				@include s-transition(default left, default transform, fast opacity);
			}
			> input[placeholder] ~ span,
			> input[value]:not([value=""]) ~ span,
			> input:focus ~ span {
				left:100%;
				@include s-translate(-100%,0);
			}
		}

		// inside
		#{s-selector((
			BEM : '.label--inside',
			SMACCS : '.label-inside'
		))} {
			display: flex;

			> * {
				flex:0;
				margin-top:0 !important;
			}
			> .input {
				flex:1;
			}

			> span {
				white-space: nowrap;
				display:inline-block;
				text-align: right;
				position:absolute;
				left:0;
				z-index:1;
			}
		}
	}
}

@mixin s-formset-label-style(
	$colors : sugar('settings.components.formset.generate.colors')
) {
	// parse properties
	@if $_sugar-test-arguments {
		// $colors : s-test-argument('s-formset','colors',map-keys(sugar('settings.colors')),$colors);
	}

	// pass in the component context
	@include s-component-context('formset') {

		// generate each colors
		@each $color in $colors {

			// label styling
			#{s-selector((
				BEM : (
					'.label--inside > .input--#{$color}:not([type="checkbox"]):not([type="radio"])',
					'.color--#{$color} .label--inside > .input:not([type="checkbox"]):not([type="radio"])'
				),
				SMACCS : (
					'.label-inside > .input-#{$color}:not([type="checkbox"]):not([type="radio"])',
					'.color-#{$color} .label-inside > .input:not([type="checkbox"]):not([type="radio"])'
				)
			))} {
				& ~ span {
					background-color: s-color($color, -opacity .05);
				}

				&:not([value=""]) ~ span,
				&:focus ~ span {
					background-color: s-color($color, -opacity .2);
					color : s-color($color, -darken 20%);
				}
			}
		}
	}
}
