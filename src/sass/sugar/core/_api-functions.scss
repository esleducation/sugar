//
// Sugar function
//
@function sugar(
	$what
) {
	@if type-of($what) == string and str-index($what, "settings.") {
		// get a configuration
		@return s-setting(str-slice($what,10));
	}
}
@function s(
	$what
) {
	@return sugar($what);
}


//
// Replace tokens
//
@function s-replace-tokens(
	$in
) {
	@if type-of($in) == list {
		$idx : 1;
		@each $item in $in {
			$in : set-nth($in, $idx, s-replace-tokens($item));
			$idx : $idx + 1;
		}
	} @else if type-of($in) == map {
		@each $idx, $item in $in {
			$in : map-set($in, $idx, s-replace-tokens($item));
		}
	} @else if type-of($in) == string and str-slice($in,1,1) == '#' {
		$color : str-slice($in,2);
		$mod-idx : str-index($color,'--');
		$mod : null;
		@if $mod-idx {
			$mod : str-slice($color,$mod-idx + 2);
			$color : str-slice($color,1,$mod-idx - 1);
		}
		$in : s-color($color, $mod);
	}
	@return $in;
}


//
// BEMize selector
//
@function s-parse-BEM-selector(
	$selector
) {
	$bem_element_separator : '__';
	$bem_modifier_separator : '--';
	$bem_state_separator : '---';

	$block : null;
	$element : null;
	$modifier : null;
	$state : null;

	// remove the .
	$selector : str-replace($selector,'.','');

	// replace items in selector

	@if str-index($selector, $bem_state_separator) {
		$split : _split($selector, $bem_state_separator);
		$selector : nth($split,1);
		// set the modifier
		$state : nth($split,2);
	}

	@if str-index($selector, $bem_modifier_separator) {
		$split : _split($selector, $bem_modifier_separator);
		$selector : nth($split,1);
		// set the modifier
		$modifier : nth($split,2);
	}

	// split block
	@if str-index($selector, $bem_element_separator) {
		$split : _split($selector, $bem_element_separator);
		$element : nth($split,2);
		$block : nth($split,1);
	} @else {
		$block : $selector
	}	

	@if $block == '' {
		$block : null;
	}

	// return the parsed selector map
	@return (
		block : $block,
		element : $element,
		modifier : $modifier,
		state : $state
	);	
}

@function s-selector(
	$map
) {
	$method : sugar('settings.selector.method');
	$sel : map-get($map,$method);
	@if not $sel {
		$sel : map-get($map,BEM);
	}
	@if not $sel {
		@error("The method #{$method} is not available in the passed selector map : #{inspect($map)}");
	}
	// join the map if needed
	@if type-of($sel) == list {
		$sel : _join($sel, ',');
	}
	// replace the --default in selector
	@if $method == BEM {
		$sel : str-replace($sel,'--default','');
	} @else if $method == SMACCS {
		$sel : str-replace($sel,'-default','');
	}
	$sel : str-replace($sel,'.default','');
	// return the selector
	@return unquote($sel);
}

//
// Get a configuration
//
$_sugar-settings-cache : ();
@function s-setting(
	$path,
	$component : $_sugar-current-component
) {
	$base_path : $path;
	@if $component == default {
		$component : null;
	}
	
	// check if has a component
	@if $component {
		$path : 'components.#{$component}.#{$path}';
	}

	// check in cache
	$cache : map-get($_sugar-settings-cache, $path);
	@if $cache {
		@return $cache;
	}

	// do not have any cache
	$parts : _split($path, '.');
	$length : length($parts);
	$idx : 0;
	$value : $_sugar-settings;
	@each $part in $parts {
		$idx : $idx + 1;
		$value : map-get($value, $part);
		// protect
		@if not $value {
			// check if a component is specified
			@if $component {
				// try to get the non component version of the setting
				// @debug('not found #{$path}, trying #{$base_path}');
				$val : s-setting($base_path, default);
				@if $val {
					$_sugar-settings-cache : map-set($_sugar-settings-cache, $path, $val) !global;
				}
				@return $val;
			} @else {
				@return null;
			}
		}

		@if $idx == $length {
			$_sugar-settings-cache : map-set($_sugar-settings-cache, $path, $value) !global;
			@return $value;
		}
	}
}


//
// Color
//
@function s-color(
	$name,
	$actions : null
) {
	// grab the colors
	$colors : sugar('settings.colors');
	$color : map-get($colors, $name);
	$modifiers : null;

	// check that we have the color
	@if $color == null {
		@if s-is($name, color) {
			$color : $name;
		} @else {
			@error('The color "#{$name}" does not exist...');
		}
	}

	// check if is a map
	@if type-of($color) == map {
		$modifiers : map-get($color, modifiers);
		$color : map-get($color, color);
	}
	
	// if the color is a string
	@if s-is($color, string) or s-is($color, color) {
		@if  index(map-keys($colors),$color) {
			@return s-color($color, $actions);
		}
	}

	// check if action is a string to check if is a modifier
	@if type-of($actions) == string and $modifiers and map-get($modifiers, $actions) {
		$mod : map-get($modifiers, $actions);
		@if type-of($mod) == color {
			$color : $mod;
			$actions : null;
		} @else {
			$actions : $mod;
		}
	}

	// check action to do
	@if $actions {
		// parse action
		$actions-map : s-parse-properties($actions, (
			hue : number,
			lighten : number,
			darken : number,
			grayscale : true,
			complement : true,
			invert : true,
			saturate : number,
			desaturate : number,
			opacity : number,
			mix : color
		), (
			hue : h,
			lighten : li,
			darken : da,
			grayscale : gr,
			complement : comp,
			invert : i,
			saturate : sa,
			desaturate : desa,
			opacity : o,
			mix : m
		));
		// loop on each action to process to keep order
		@each $action, $value in $actions-map {
			// hue
			@if $action == hue and type-of($value) == number {
				$color : adjust-hue($color, $value);
			}
			// lighten
			@if $action == lighten and type-of($value) == number {
				$color : lighten($color, $value);
			}
			// darken
			@if $action == darken and type-of($value) == number {
				$color : darken($color, $value);
			}
			// saturate
			@if $action == saturate and type-of($value) == number {
				$color : saturate($color, $value);
			}
			// desaturate
			@if $action == desaturate and type-of($value) == number {
				$color : desaturate($color, $value);
			}
			// grayscale
			@if $action == grayscale and $value == true {
				$color : grayscale($color);
			}
			// complement
			@if $action == complement and $value == true {
				$color : complement($color);
			}
			// invert
			@if $action == invert and $value == true {
				$color : invert($color);
			}
			// opacity
			@if $action == opacity and type-of($value) == number {

				$transparentize : 1 - s-strip-units($value);
				@if unit($value) == '%' {
					$transparentize : (100 - s-strip-units($value)) / 100;
				}
				$color : transparentize($color, $transparentize);
			}
			// mix
			@if $action == mix and type-of($value) == color {
				$color : mix($color, $value);
			}
		}
	}
	// return the color
	@return $color;
}

//
// Check a variable type
//
@function s-is(
	$value,
	$type
) {

	@if type-of($type) == string and str-index($type,'|') {
		$type : _split($type,'|');
	}

	@if type-of($type) == list {
		$ok : false;
		@each $t in $type {
			@if s-is($value, $t) {
				$ok : true;
			}
		}
		@return $ok;
	} @else {

		// @if type-of($type) != string {
		// 	@return true;
		// }
		
		@if $type == mixed {
			@return true;
		} @else if $type == null or $type == 'null' {
			@return _is-null($value);
		} @else if $type == url {
			@return str-is-url($value);
		} @else if str-index($type, 'map-') {
			$idx : str-index($type, '-');
			$type : str-slice($type, $idx + 1);
			@each $prop, $val in $value {
				@if $val and not s-is($val, $type) {
					@return false;
				}
			}
			@return true;
		} @else if str-index($type, 'list-') {
			$idx : str-index($type, '-');
			$type : str-slice($type, $idx + 1);
			@each $item in $value {
				@if $item and not s-is($item, $type) {
					@return false;
				}
			}
			@return true;
		} @else if $type == px {
			@return type-of($value) == number and not unitless($value) and unit($value) == px;
		} @else if $type == rem {
			@return type-of($value) == number and not unitless($value) and unit($value) == rem;
		} @else if $type == em {
			@return type-of($value) == number and not unitless($value) and unit($value) == em;
		} @else if $type == pt {
			@return type-of($value) == number and not unitless($value) and unit($value) == pt;
		} @else if $type == percent or $type == '%' {
			@return type-of($value) == number and not unitless($value) and unit($value) == '%';
		} @else if $type == vw {
			@return type-of($value) == number and not unitless($value) and unit($value) == vw;
		} @else if $type == vh {
			@return type-of($value) == number and not unitless($value) and unit($value) == vh;
		} @else if $type == ex {
			@return type-of($value) == number and not unitless($value) and unit($value) == ex;
		} @else if $type == ch {
			@return type-of($value) == number and not unitless($value) and unit($value) == ch;
		} @else if $type == cm {
			@return type-of($value) == number and not unitless($value) and unit($value) == cm;
		} @else if $type == mm {
			@return type-of($value) == number and not unitless($value) and unit($value) == mm;
		} @else if $type == in {
			@return type-of($value) == number and not unitless($value) and unit($value) == in;
		} @else if $type == pc {
			@return type-of($value) == number and not unitless($value) and unit($value) == pc;
		} @else if $type == s or $type == second {
			@return type-of($value) == number and not unitless($value) and unit($value) == s;
		} @else if $type == boolean or $type == bool {
			@return _is-boolean($value);
		} @else if $type == function {
			@return _is-function($value);
		} @else if $type == null {
			@return _is-null($value);
		} @else if $type == number {
			@return type-of($value) == number;
		} @else if $type == integer or $type == int {
			@if type-of($value) != number {
				@return false;
			}
			@return round($value) == $value;
		} @else if $type == string {
			@return type-of($value) == string;
		} @else if $type == color {
			@return type-of($value) == color;
		} @else if $type == list {
			@return type-of($value) == list;
		} @else if $type == map {
			@return type-of($value) == map;
		} @else if $type == degree or $type == deg {
			@return unit($value) == deg;
		}
	}
	// default return
	@return false;
}


//
// Interpolate
//
@function s-interpolate(
	$stack,
	$size
) {
	@if not $stack or type-of($stack) != string {
		@error('The value "#{$stack}" is not a settings path');
	}
	
	// get the value	
	$value : sugar('#{$stack}.#{$size}');

	// if we have a value with units, return
	@if $value and not unitless($value) {
		@return $value;
	}
	
	// get what we need to interpolate the value
	$ratio : sugar('settings.sizes.#{$size}');
	$default-size : sugar('#{$stack}.default');

	// if the getted value is a unitless one, mean that it's the ratio to use
	// to interpolate the default stack value
	@if $value and unitless($value) {
		$ratio : $value;
	}

	// protect
	@if not $default-size {
		@error("You need to specify a #{$stack}.default setting...");
	}
	@if not unit($default-size) {
		@error("Your #{$stack}.default has to have a unit like rem, px, etc...");
	}
	@if not $ratio {
		@error("You need to have the sizes.#{$size} specified in order to interpolate the value to this size...");
	}

	// if no value, interpolate the default one with the size ratio
	@if not $value or unitless($value) {
		@return $default-size * $ratio;
	}

	// if not number
	@if type-of($value) != number {
		@error('You cannot interpolate the value "#{$value}" cause it is not a number...');
	}

	// default return the value
	@return $value;
}


//
// Space
//
@function s-space(
	$size
) {
	@return s-round-px-value(s-interpolate('settings.spaces', $size));
}


//
// Get a look and feel value
//
@function s-look-and-feel(
	$name,
	$size : default
) {
	// protect 
	@if not s-is($name, string) {
		@error("the s-look-and-feel name parameter has to be a string corresponding to a look and feel setting...");
	}

	// initial value
	$value : sugar('settings.look-and-feel.#{$name}.#{$size}');

	// if we have a non number value, return it
	@if $value and type-of($value) != number {
		@return s-replace-tokens(s-round-px-value($value));
	}

	// if we have a number value, return the interpolated version
	@return s-round-px-value(s-interpolate('settings.look-and-feel.#{$name}', $size));

	// we don't have anything...
	@return null;
}

//
// Round a value to match a round px render
//
@function s-round-px-value($value) {
	$value : call('s-#{unit($value)}',round(s-px($value)));
	@return $value;
}


//
// Round a value to match a round px render => even
//
@function s-round-px-value-even($value) {
	$value : call('s-#{unit($value)}',s-even(s-px($value)));
	@return $value;
}


//
// Round a value to match a round px render => odd
//
@function s-round-px-value-odd($value) {
	$value : call('s-#{unit($value)}',s-odd(s-px($value)));
	@return $value;
}


//
// Make a number even
//
@function s-even($value) {
	$value : round($value);
	$dec : $value % 1;
	@if s-strip-units($value) % 2 != 0 {
		@if $dec >= .5 {
			$value : $value + 1;
		} @else {
			$value : $value - 1;
		}
	}
	@return $value;
}


//
// Make a number odd
//
@function s-odd($value) {
	$value : round($value);
	$dec : $value % 1;
	@if s-strip-units($value) % 2 == 0 {
		@if $dec >= .5 {
			$value : $value + 1;
		} @else {
			$value : $value - 1;
		}
	}
	@return $value;
}


//
// Strip units
//
@function s-strip-units($number) {
	@return $number / ($number * 0 + 1);
}