//
// Sugar function
//
@function sugar(
	$what
) {
	@if type-of($what) == string and str-index($what, "settings.") {
		// get a configuration
		@return s-setting(str-slice($what,10));
	}
}
@function s(
	$what
) {
	@return sugar($what);
}


//
// Replace tokens
//
@function s-replace-tokens(
	$in
) {
	@if type-of($in) == list {
		$idx : 1;
		@each $item in $in {
			$in : set-nth($in, $idx, s-replace-tokens($item));
			$idx : $idx + 1;
		}
	} @else if type-of($in) == map {
		@each $idx, $item in $in {
			$in : map-set($in, $idx, s-replace-tokens($item));
		}
	} @else if type-of($in) == string and str-slice($in,1,1) == '#' {
		$color : str-slice($in,2);
		$mod-idx : str-index($color,'--');
		$mod : null;
		@if $mod-idx {
			$mod : str-slice($color,$mod-idx + 2);
			$color : str-slice($color,1,$mod-idx - 1);
		}
		$in : s-color($color, $mod);
	}
	@return $in;
}


//
// BEMize selector
//
@function s-parse-BEM-selector(
	$selector
) {
	$bem_element_separator : '__';
	$bem_modifier_separator : '--';
	$bem_state_separator : '---';

	$block : null;
	$element : null;
	$modifier : null;
	$state : null;

	// remove the .
	$selector : str-replace($selector,'.','');

	// replace items in selector

	@if str-index($selector, $bem_state_separator) {
		$split : _split($selector, $bem_state_separator);
		$selector : nth($split,1);
		// set the modifier
		$state : nth($split,2);
	}

	@if str-index($selector, $bem_modifier_separator) {
		$split : _split($selector, $bem_modifier_separator);
		$selector : nth($split,1);
		// set the modifier
		$modifier : nth($split,2);
	}

	// split block
	@if str-index($selector, $bem_element_separator) {
		$split : _split($selector, $bem_element_separator);
		$element : nth($split,2);
		$block : nth($split,1);
	} @else {
		$block : $selector
	}	

	@if $block == '' {
		$block : null;
	}

	// return the parsed selector map
	@return (
		block : $block,
		element : $element,
		modifier : $modifier,
		state : $state
	);	
}

@function s-selector(
	$map
) {
	$method : sugar('settings.selector.method');
	$sel : map-get($map,$method);
	@if not $sel {
		$sel : map-get($map,BEM);
	}
	@if not $sel {
		@error("The method #{$method} is not available in the passed selector map : #{inspect($map)}");
	}
	// join the map if needed
	@if type-of($sel) == list {
		$sel : _join($sel, ',');
	}
	// replace the --default in selector
	@if $method == BEM {
		$sel : str-replace($sel,'--default','');
	} @else if $method == SMACCS {
		$sel : str-replace($sel,'-default','');
	}
	$sel : str-replace($sel,'.default','');
	// return the selector
	@return $sel;
}

//
// Get a configuration
//
$_sugar-settings-cache : ();
@function s-setting(
	$path
) {
	// check in cache
	$cache : map-get($_sugar-settings-cache, $path);
	@if $cache {
		@return $cache;
	}

	// do not have any cache
	$parts : _split($path, '.');
	$length : length($parts);
	$idx : 0;
	$value : $_sugar-settings;
	@each $part in $parts {
		$idx : $idx + 1;
		// protect
		@if not s-is($value, map) {
			@return null;
			// @error("Something went wrong when retreiving the '#{$path}' setting...");
		}
		$value : map-get($value, $part);
		@if $idx == $length {
			$_sugar-settings-cache : map-set($_sugar-settings-cache, $path, $value) !global;
			@return $value;
		}
	}
}


//
// Color
//
@function s-color(
	$name,
	$actions : null
) {
	// grab the colors
	$colors : sugar('settings.colors');
	$color : map-get($colors, $name);
	$modifiers : null;

	// check that we have the color
	@if $color == null {
		@if s-is($name, color) {
			$color : $name;
		} @else {
			@error('The color "#{$name}" does not exist...');
		}
	}

	// check if is a map
	@if type-of($color) == map {
		$modifiers : map-get($color, modifiers);
		$color : map-get($color, color);
	}
	
	// if the color is a string
	@if s-is($color, string) or s-is($color, color) {
		@if  index(map-keys($colors),$color) {
			@return s-color($color, $actions);
		}
	}

	// check if action is a string to check if is a modifier
	@if type-of($actions) == string and $modifiers and map-get($modifiers, $actions) {
		$mod : map-get($modifiers, $actions);
		@if type-of($mod) == color {
			$color : $mod;
			$actions : null;
		} @else {
			$actions : $mod;
		}
	}

	// check action to do
	@if $actions {
		// parse action
		$actions-map : s-parse-properties($actions, (
			hue : number,
			lighten : number,
			darken : number,
			grayscale : true,
			complement : true,
			invert : true,
			saturate : number,
			desaturate : number,
			opacity : number,
			mix : color
		), (
			hue : h,
			lighten : li,
			darken : da,
			grayscale : gr,
			complement : comp,
			invert : i,
			saturate : sa,
			desaturate : desa,
			opacity : o,
			mix : m
		));
		// loop on each action to process to keep order
		@each $action, $value in $actions-map {
			// hue
			@if $action == hue and type-of($value) == number {
				$color : adjust-hue($color, $value);
			}
			// lighten
			@if $action == lighten and type-of($value) == number {
				$color : lighten($color, $value);
			}
			// darken
			@if $action == darken and type-of($value) == number {
				$color : darken($color, $value);
			}
			// saturate
			@if $action == saturate and type-of($value) == number {
				$color : saturate($color, $value);
			}
			// desaturate
			@if $action == desaturate and type-of($value) == number {
				$color : desaturate($color, $value);
			}
			// grayscale
			@if $action == grayscale and $value == true {
				$color : grayscale($color);
			}
			// complement
			@if $action == complement and $value == true {
				$color : complement($color);
			}
			// invert
			@if $action == invert and $value == true {
				$color : invert($color);
			}
			// opacity
			@if $action == opacity and type-of($value) == number {

				$transparentize : 1 - s-strip-units($value);
				@if unit($value) == '%' {
					$transparentize : (100 - s-strip-units($value)) / 100;
				}
				$color : transparentize($color, $transparentize);
			}
			// mix
			@if $action == mix and type-of($value) == color {
				$color : mix($color, $value);
			}
		}
	}
	// return the color
	@return $color;
}

//
// Check a variable type
//
@function s-is(
	$value,
	$type
) {
	@if type-of($type) != string {
		@return true;
	}

	@if $type == url {
		@return str-is-url($value);
	} @else if str-index($type, 'map-') {
		$idx : str-index($type, '-');
		$type : str-slice($type, $idx + 1);
		@each $prop, $val in $value {
			@if $val and not s-is($val, $type) {
				@return false;
			}
		}
		@return true;
	} @else if str-index($type, 'list-') {
		$idx : str-index($type, '-');
		$type : str-slice($type, $idx + 1);
		@each $item in $value {
			@if $item and not s-is($item, $type) {
				@return false;
			}
		}
		@return true;
	} @else if $type == px {
		@return type-of($value) == number and not unitless($value) and unit($value) == px;
	} @else if $type == rem {
		@return type-of($value) == number and not unitless($value) and unit($value) == rem;
	} @else if $type == em {
		@return type-of($value) == number and not unitless($value) and unit($value) == em;
	} @else if $type == pt {
		@return type-of($value) == number and not unitless($value) and unit($value) == pt;
	} @else if $type == percent or $type == '%' {
		@return type-of($value) == number and not unitless($value) and unit($value) == '%';
	} @else if $type == vw {
		@return type-of($value) == number and not unitless($value) and unit($value) == vw;
	} @else if $type == vh {
		@return type-of($value) == number and not unitless($value) and unit($value) == vh;
	} @else if $type == ex {
		@return type-of($value) == number and not unitless($value) and unit($value) == ex;
	} @else if $type == ch {
		@return type-of($value) == number and not unitless($value) and unit($value) == ch;
	} @else if $type == cm {
		@return type-of($value) == number and not unitless($value) and unit($value) == cm;
	} @else if $type == mm {
		@return type-of($value) == number and not unitless($value) and unit($value) == mm;
	} @else if $type == in {
		@return type-of($value) == number and not unitless($value) and unit($value) == in;
	} @else if $type == pc {
		@return type-of($value) == number and not unitless($value) and unit($value) == pc;
	} @else if $type == s or $type == second {
		@return type-of($value) == number and not unitless($value) and unit($value) == s;
	} @else if $type == boolean or $type == bool {
		@return _is-boolean($value);
	} @else if $type == function {
		@return _is-function($value);
	} @else if $type == null {
		@return _is-null($value);
	} @else if $type == number {
		@return type-of($value) == number;
	} @else if $type == integer or $type == int {
		@if type-of($value) != number {
			@return false;
		}
		@return round($value) == $value;
	} @else if $type == string {
		@return type-of($value) == string;
	} @else if $type == color {
		@return type-of($value) == color;
	} @else if $type == list {
		@return type-of($value) == list;
	} @else if $type == map {
		@return type-of($value) == map;
	} @else if $type == degree or $type == deg {
		@return unit($value) == deg;
	}
}


//
// Interpolate
//
@function s-size(
	$value,
	$size
) {
	$sizes : sugar('settings.sizes');
	// protect
	@if not s-is($value, number) {
		@error("Your value need to be a number for the s-size function...");
	}
	@if not s-is($size, string) {
		@error("Your ratio parameter need to be a string for the s-size function... You just passed #{$size}");
	}
	@if not map-get($sizes, $size) {
		@error("Your passed size #{$size} does not existin in sizes.#{$size}...");
	}

	// process calculation
	@return s-round-px-value($value * map-get($sizes, $size));
}


//
// Ratioize
//
@function _s-sizeize(
	$size,
	$sizes : null
) {
	$_sizes : sugar('settings.sizes');
	$default-size : map-get($sizes, default);
	
	// protect
	@if not $default-size {
		@error("You need to specify a sizes.default setting...");
	}
	@if not unit($default-size) {
		@error("Your sizes.default has to have a unit like rem, px, etc...");
	}
	@if $sizes {
		$s : map-get($sizes, $size);
		@if $s and s-is($s, number) and not unitless($s) {
			@return $s;
		}
		@if s-is($s, number) and unitless($s) {
			@return $default-size * $s;
		}
		@if not $s and type-of($size) == string {
			// protect
			$size : map-get($_sizes, $size);
			@if not $size or not unitless($size) {
				@error("You need to specify a valid ratio for sizes.#{$size} un your settings...");
			}
			@return $default-size * $size;
		}
	} @else {
		$size : map-get($sizes, $size);
		@if not $size or not unitless($size) {
			@error("You need to specify a valid ratio for ratio.#{$size} un your settings...");
		}
	}
	@if s-is($size, number) and unitless($size) {
		@return s-rem($size);
	}
	@return $size;
}


//
// Size
//
@function s-space(
	$size
) {
	$sizes : sugar('settings.spaces');
	@return s-round-px-value(_s-sizeize($size, $sizes));
}


//
// Get a look and feel value
//
@function s-look-and-feel(
	$name,
	$size : default,
	$component : $_sugar-current-component
) {
	// protect 
	@if not s-is($name, string) {
		@error("the s-look-and-feel name parameter has to be a string corresponding to a look and feel setting...");
	}

	// initial value
	$value : null;

	// check if is a component
	$component_path : '';
	@if $component {
		$component_path : '#{$component}.';
	}

	$value : sugar('settings.#{$component_path}look-and-feel.#{$size}.#{$name}');
	@if not $value and $component {
		$value : sugar('settings.look-and-feel.#{$size}.#{$name}');
	}



	// get values
	// $lnf : sugar('settings.#{$component_path}look-and-feel.#{$size}');
	// // if is a component and no look and feel
	// @if $component and not $lnf {
	// 	$lnf : sugar('settings.look-and-feel.#{$size}');
	// }

	// // get the actual value
	// @if $lnf {
	// 	$value : map-get($lnf, $name);
	// }

	// if we have a value, return it
	@if $value {
		@return s-replace-tokens(s-round-px-value($value));
	}

	// if we don't have any value and the size is default
	@if $size == default {
		@error("The look and feel value #{$name} does not exist...");
	}

	// check if we can interpolate the value
	$default : sugar('settings.#{$component_path}look-and-feel.default.#{$name}');
	// if we have a component and not any default, get the default from default look and feel
	@if $component and not $default {
		$default : sugar('settings.look-and-feel.default.#{$name}');
	}
	$_ratio : sugar('settings.sizes.#{$size}');
	@if not $default or not $_ratio {
		@error("It's not possible to interpolate your look and feel #{$name} value cause you miss either the #{$component_path}look-and-feel.default.#{$name} setting, or the ratios.#{$size} one...");
	}

	// protect against string interpolation etc...
	@if type-of($default) != number {
		@error("You try to interpolate the #{$component_path}look-and-feel.default.#{$name} : #{$default} value that is not a number...");
	}

	// interpolate
	@return s-size($default, $size);

}

//
// Round a value to match a round px render
//
@function s-round-px-value($value) {
	$value : call('s-#{unit($value)}',round(s-px($value)));
	@return $value;
}


//
// Round a value to match a round px render => even
//
@function s-round-px-value-even($value) {
	$value : call('s-#{unit($value)}',s-even(s-px($value)));
	@return $value;
}


//
// Round a value to match a round px render => odd
//
@function s-round-px-value-odd($value) {
	$value : call('s-#{unit($value)}',s-odd(s-px($value)));
	@return $value;
}


//
// Make a number even
//
@function s-even($value) {
	$value : round($value);
	$dec : $value % 1;
	@if s-strip-units($value) % 2 != 0 {
		@if $dec >= .5 {
			$value : $value + 1;
		} @else {
			$value : $value - 1;
		}
	}
	@return $value;
}


//
// Make a number odd
//
@function s-odd($value) {
	$value : round($value);
	$dec : $value % 1;
	@if s-strip-units($value) % 2 == 0 {
		@if $dec >= .5 {
			$value : $value + 1;
		} @else {
			$value : $value - 1;
		}
	}
	@return $value;
}


//
// Strip units
//
@function s-strip-units($number) {
	@return $number / ($number * 0 + 1);
}