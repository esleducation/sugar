//
// Sugar function
//
@function sugar(
	$what
) {
	@if type-of($what) == string and str-index($what, "settings.") {
		// get a configuration
		@return s-setting(str-slice($what,10));
	}
}
@function s(
	$what
) {
	@return sugar($what);
}


/**
 * Transform -var value -var value value to map
 */
@function s-dash-to-map(
	$dash
) {
	$prop : null;
	$values : ();
	$map : ();
	// protect
	@if type-of($dash) != list or str-slice(nth($dash,1),1,1) != '-' {
		@return $dash;
	}
	// loop on each properties
	@each $d in $dash {
		@if type-of($d) == string and str-slice($d,1,1) == '-' {
			// check if a prop exist and if values exists
			@if $prop and length($values) > 0 {
				@if length($values) == 1 {
					$values : nth($values,1);
				}
				$map : map-set($map, $prop, $values);
				$values : ();
			}
			// set new prop
			$prop : str-slice($d,2);
			// check if 
		} @else {
			// append values
			$values : append($values,$d);
		}
	}
	// check if a prop exist and if values exists
	@if $prop and length($values) > 0 {
		@if length($values) == 1 {
			$values : nth($values,1);
		}
		$map : map-set($map, $prop, $values);
	}
	// return the map
	@return $map;
}


//
// Replace tokens
//
@function s-replace-tokens(
	$in
) {
	@if type-of($in) == list {
		$idx : 1;
		@each $item in $in {
			$in : set-nth($in, $idx, s-replace-tokens($item));
			$idx : $idx + 1;
		}
	} @else if type-of($in) == map {
		@each $idx, $item in $in {
			$in : map-set($in, $idx, s-replace-tokens($item));
		}
	} @else if type-of($in) == string and str-slice($in,1,1) == '#' {
		$color : str-slice($in,2);
		$mod-idx : str-index($color,'--');
		$mod : null;
		@if $mod-idx {
			$mod : str-slice($color,$mod-idx + 2);
			$color : str-slice($color,1,$mod-idx - 1);
		}
		$in : s-color($color, $mod);
	}
	@return $in;
}


//
// BEMize selector
//
@function s-parse-BEM-selector(
	$selector
) {
	$bem_element_separator : '__';
	$bem_modifier_separator : '--';
	$bem_state_separator : '---';

	$block : null;
	$element : null;
	$modifier : null;
	$state : null;

	// remove the .
	$selector : str-replace($selector,'.','');

	// replace items in selector

	@if str-index($selector, $bem_state_separator) {
		$split : _split($selector, $bem_state_separator);
		$selector : nth($split,1);
		// set the modifier
		$state : nth($split,2);
	}

	@if str-index($selector, $bem_modifier_separator) {
		$split : _split($selector, $bem_modifier_separator);
		$selector : nth($split,1);
		// set the modifier
		$modifier : nth($split,2);
	}

	// split block
	@if str-index($selector, $bem_element_separator) {
		$split : _split($selector, $bem_element_separator);
		$element : nth($split,2);
		$block : nth($split,1);
	} @else {
		$block : $selector
	}	

	@if $block == '' {
		$block : null;
	}

	// return the parsed selector map
	@return (
		block : $block,
		element : $element,
		modifier : $modifier,
		state : $state
	);	
}

//
// Declare multiple selectors for BEM, SMACCS, and maybe others
// syntax in the futur
//
@function s-selector(
	$map,
	$vertical-rhythme-scope : false
) {
	$method : sugar('settings.selector.method');
	$sel : map-get($map,$method);
	@if not $sel {
		$sel : map-get($map,BEM);
	}
	@if not $sel {
		@error("The method #{$method} is not available in the passed selector map : #{inspect($map)}");
	}
	// join the map if needed
	@if type-of($sel) == list {
		$sel : _join($sel, ',');
	}
	// check if need to scope vertical rhythme
	@if $vertical-rhythme-scope {
		// split
		$sels : _split($sel,',');
		$new_sels : ();
		@each $s in $sels {
			$s : #{s-vertical-rhythme-scope-class()}#{$s};
			$new_sels : append($new_sels, $s);
		}
		$sel : _join($new_sels,',');
	}
	// replace the --default in selector
	@if $method == BEM {
		$sel : str-replace($sel,'--default','');
	} @else if $method == SMACCS {
		$sel : str-replace($sel,'-default','');
	}
	$sel : str-replace($sel,'.default','');
	// return the selector
	@return unquote($sel);
}

//
// Get a configuration
//
$_sugar-settings-cache : ();
@function s-setting(
	$path,
	$component : $_sugar-current-component
) {
	$base_path : $path;
	@if $component == default {
		$component : null;
	}
	
	// check if has a component
	@if $component {
		$path : 'components.#{$component}.#{$path}';
	}

	// check in cache
	$cache : map-get($_sugar-settings-cache, $path);
	@if $cache {
		@return $cache;
	}

	// do not have any cache
	$parts : _split($path, '.');
	$length : length($parts);
	$idx : 0;
	$value : $_sugar-settings;
	@each $part in $parts {
		$idx : $idx + 1;
		$value : map-get($value, $part);
		// protect
		@if not $value {
			// check if a component is specified
			@if $component {
				// try to get the non component version of the setting
				// @debug('not found #{$path}, trying #{$base_path}');
				$val : s-setting($base_path, default);
				@if $val {
					$_sugar-settings-cache : map-set($_sugar-settings-cache, $path, $val) !global;
				}
				@return $val;
			} @else {
				@return null;
			}
		}

		@if $idx == $length {
			$_sugar-settings-cache : map-set($_sugar-settings-cache, $path, $value) !global;
			@return $value;
		}
	}
}


//
// Color
//
@function s-color(
	$name,
	$actions : null
) {
	// dash syntax
	@if $actions and type-of($actions) == list {
		@return s-color($name, s-dash-to-map($actions));
	}

	// grab the colors
	$colors : sugar('settings.colors');

	// test parameters
	@if $_sugar-test-arguments {
		$name : s-test-argument('s-color','name','color|string',$name);
		$actions : s-test-argument('s-color','actions','map|string',$actions);
	}

	$color : map-get($colors, $name);
	$modifiers : null;

	// check that we have the color
	@if $color == null {
		@if s-is($name, color) {
			$color : $name;
		} @else {
			@error('The color "#{$name}" does not exist...');
		}
	}

	// check if is a map
	@if type-of($color) == map {
		$modifiers : map-get($color, modifiers);
		$color : map-get($color, color);
	}
	
	// if the color is a string
	@if s-is($color, string) or s-is($color, color) {
		@if  index(map-keys($colors),$color) {
			@return s-color($color, $actions);
		}
	}

	// check if action is a string to check if is a modifier
	@if type-of($actions) == string and $modifiers and map-get($modifiers, $actions) {
		$mod : map-get($modifiers, $actions);
		@if type-of($mod) == color {
			$color : $mod;
			$actions : null;
		} @else if type-of($mod) == list {
			$actions : s-dash-to-map($mod);
		} @else if type-of($mod) == map {
			$actions : $mod;
		} @else {
			@error('The color "#{$name}" "actions" parameter set as "#{$actions}" for the "s-color" function is not valid');
		}
	}

	// check action to do
	@if $actions {
		// check arguments
		@if $_sugar-test-arguments {
			@if type-of($actions) == map {
				$hue : s-test-argument('s-color','actions.hue',number,map-get($actions,hue));
				$lighten : s-test-argument('s-color','actions.lighten',number,map-get($actions,lighten));
				$darken : s-test-argument('s-color','actions.darken',number,map-get($actions,darken));
				$saturate : s-test-argument('s-color','actions.saturate',number,map-get($actions,saturate));
				$desaturate : s-test-argument('s-color','actions.desaturate',number,map-get($actions,desaturate));
				$grayscale : s-test-argument('s-color','actions.grayscale',boolean,map-get($actions,grayscale));
				$complement : s-test-argument('s-color','actions.complement',boolean,map-get($actions,complement));
				$invert : s-test-argument('s-color','actions.invert',boolean,map-get($actions,invert));
				$opacity : s-test-argument('s-color','actions.opacity',number,map-get($actions,opacity));
				$mix : s-test-argument('s-color','actions.mix',color,map-get($actions,mix));
			} @else if type-of($actions) == string {
				$modifiers : sugar('settings.colors.#{$name}.modifiers');
				@if not $modifiers {
					@error('The color "#{$name} does not have any "#{$actions}" modifier...');
				}
				$actions : s-test-argument('s-color','actions',map-keys(sugar('settings.colors.#{$name}.modifiers')),$actions);
			}
		}

		// loop on each action to process to keep order
		@each $action, $value in $actions {
			// hue
			@if $action == hue {
				$color : adjust-hue($color, $value);
			}
			// lighten
			@if $action == lighten {
				$color : lighten($color, $value);
			}
			// darken
			@if $action == darken {
				$color : darken($color, $value);
			}
			// saturate
			@if $action == saturate {
				$color : saturate($color, $value);
			}
			// desaturate
			@if $action == desaturate {
				$color : desaturate($color, $value);
			}
			// grayscale
			@if $action == grayscale and $value == true {
				$color : grayscale($color);
			}
			// complement
			@if $action == complement and $value == true {
				$color : complement($color);
			}
			// invert
			@if $action == invert and $value == true {
				$color : invert($color);
			}
			// opacity
			@if $action == opacity and type-of($value) == number {

				$transparentize : 1 - s-strip-units($value);
				@if unit($value) == '%' {
					$transparentize : (100 - s-strip-units($value)) / 100;
				}
				$color : transparentize($color, $transparentize);
			}
			// mix
			@if $action == mix and type-of($value) == color {
				$color : mix($color, $value);
			}
		}
	}
	// return the color
	@return $color;
}

//
// Check a variable type
//
@function s-is(
	$value,
	$type
) {

	@if type-of($type) == string and str-index($type,'|') {
		$type : _split($type,'|');
	}

	@if type-of($type) == list {
		$ok : false;
		@each $t in $type {
			@if s-is($value, $t) {
				$ok : true;
			}
		}
		@return $ok;
	} @else {
		
		@if $type == mixed {
			@return true;
		} @else if $type == null or $type == 'null' {
			@return _is-null($value);
		} @else if $type == url {
			@return str-is-url($value);
		} @else if str-index($type, 'map-') {
			$idx : str-index($type, '-');
			$type : str-slice($type, $idx + 1);
			@each $prop, $val in $value {
				@if $val and not s-is($val, $type) {
					@return false;
				}
			}
			@return true;
		} @else if str-index($type, 'list-') {
			$idx : str-index($type, '-');
			$type : str-slice($type, $idx + 1);
			@each $item in $value {
				@if $item and not s-is($item, $type) {
					@return false;
				}
			}
			@return true;
		} @else if $type == px {
			@return type-of($value) == number and not unitless($value) and unit($value) == px;
		} @else if $type == rem {
			@return type-of($value) == number and not unitless($value) and unit($value) == rem;
		} @else if $type == em {
			@return type-of($value) == number and not unitless($value) and unit($value) == em;
		} @else if $type == pt {
			@return type-of($value) == number and not unitless($value) and unit($value) == pt;
		} @else if $type == percent or $type == '%' {
			@return type-of($value) == number and not unitless($value) and unit($value) == '%';
		} @else if $type == vw {
			@return type-of($value) == number and not unitless($value) and unit($value) == vw;
		} @else if $type == vh {
			@return type-of($value) == number and not unitless($value) and unit($value) == vh;
		} @else if $type == ex {
			@return type-of($value) == number and not unitless($value) and unit($value) == ex;
		} @else if $type == ch {
			@return type-of($value) == number and not unitless($value) and unit($value) == ch;
		} @else if $type == cm {
			@return type-of($value) == number and not unitless($value) and unit($value) == cm;
		} @else if $type == mm {
			@return type-of($value) == number and not unitless($value) and unit($value) == mm;
		} @else if $type == in {
			@return type-of($value) == number and not unitless($value) and unit($value) == in;
		} @else if $type == pc {
			@return type-of($value) == number and not unitless($value) and unit($value) == pc;
		} @else if $type == s or $type == second {
			@return type-of($value) == number and not unitless($value) and unit($value) == s;
		} @else if $type == boolean or $type == bool {
			@return _is-boolean($value);
		} @else if $type == function {
			@return _is-function($value);
		} @else if $type == null {
			@return _is-null($value);
		} @else if $type == number {
			@return type-of($value) == number;
		} @else if $type == integer or $type == int {
			@if type-of($value) != number {
				@return false;
			}
			@return round($value) == $value;
		} @else if $type == string {
			@return type-of($value) == string;
		} @else if $type == color {
			@return type-of($value) == color;
		} @else if $type == list {
			@return type-of($value) == list;
		} @else if $type == map {
			@return type-of($value) == map;
		} @else if $type == degree or $type == deg {
			@return unit($value) == deg;
		}
	}
	// default return
	@return false;
}


//
// Interpolate
//
@function s-interpolate(
	$stack,
	$size
) {
	@if not $stack or type-of($stack) != string {
		@error('The value "#{$stack}" is not a settings path');
	}
	
	// get the value	
	$value : sugar('#{$stack}.#{$size}');

	// if we have a value with units, return
	@if $value and not unitless($value) {
		@return $value;
	}
	
	// get what we need to interpolate the value
	$ratio : sugar('settings.sizes.#{$size}');
	$default-size : sugar('#{$stack}.default');

	// if the getted value is a unitless one, mean that it's the ratio to use
	// to interpolate the default stack value
	@if $value and unitless($value) {
		$ratio : $value;
	}

	// protect
	@if not $default-size {
		@error("You need to specify a #{$stack}.default setting...");
	}
	@if not unit($default-size) {
		@error("Your #{$stack}.default has to have a unit like rem, px, etc...");
	}
	@if not $ratio {
		@error("You need to have the sizes.#{$size} specified in order to interpolate the value to this size...");
	}

	// if no value, interpolate the default one with the size ratio
	@if not $value or unitless($value) {
		@return $default-size * $ratio;
	}

	// if not number
	@if type-of($value) != number {
		@error('You cannot interpolate the value "#{$value}" cause it is not a number...');
	}

	// default return the value
	@return $value;
}


//
// Space
//
@function s-space(
	$size
) {
	@return s-render-round(s-interpolate('settings.spaces', $size));
}


//
// Get a look and feel value
//
@function s-look-and-feel(
	$name,
	$size : default
) {
	// protect 
	@if not s-is($name, string) {
		@error("the s-look-and-feel name parameter has to be a string corresponding to a look and feel setting...");
	}

	// initial value
	$value : sugar('settings.look-and-feel.#{$name}.#{$size}');

	// if we have a non number value, return it
	@if $value and type-of($value) != number {
		@return s-replace-tokens(s-render-round($value));
	}

	// if we have a number value, return the interpolated version
	@return s-render-round(s-interpolate('settings.look-and-feel.#{$name}', $size));

	// we don't have anything...
	@return null;
}
@function s-lnf(
	$name,
	$size : default
) {
	@return s-look-and-feel($name, $size);
}

//
// Round a value to match a round px render
//
@function s-render-round($value) {
	$value : call('s-#{unit($value)}',round(s-px($value)));
	@return $value;
}


//
// Round a value to match a round px render => even
//
@function s-render-round-even($value) {
	$value : call('s-#{unit($value)}',s-even(s-px($value)));
	@return $value;
}


//
// Round a value to match a round px render => odd
//
@function s-render-round-odd($value) {
	$value : call('s-#{unit($value)}',s-odd(s-px($value)));
	@return $value;
}


//
// Make a number even
//
@function s-even($value) {
	$d : s-strip-units($value % 2);
	$value : round($value);
	@if s-strip-units($value) % 2 != 0 {
		@if $d >= 1 {
			$value : $value + 1;
		} @else {
			$value : $value - 1;
		}
	}
	@return $value;
}


//
// Make a number odd
//
@function s-odd($value) {
	$dec : s-strip-units($value % 2);
	$value : round($value);
	@if s-strip-units($value) % 2 == 0 {
		@if $dec >= 1 {
			$value : $value + 1;
		} @else {
			$value : $value - 1;
		}
	}
	@return $value;
}