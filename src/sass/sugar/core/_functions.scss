//
// Handle nested
//

@function s-test-argument(
	$method,
	$property,
	$type,
	$value,
	$check-only : false
) {
	// check if not value
	@if not $value {
		@return $value;
	}
	// check explicit values
	@if type-of($type) == string {
		// check the type
		@if not s-is($value, $type) {
			@if $check-only {
				@return false;
			}
			@error('The property "#{$property}" of the mixin/function "#{$method}" need to be a "#{$type}" but it seems that you pass a "#{type-of($value)}" : #{$value}');
		}
		@return $value;
	} @else if type-of($type) == list {
		// check if the passed value exist in possible values
		@if type-of($value) == list and index($type, length) {
			@return $value;
		} @else if type-of($value) == number and index($type, length) {
			@return $value;
		} @else {
			// if its a list of values, check each values
			@if type-of($value) == list {
				@each $v in $value {
					@if not _s-check-property($property, $type, $v, true) {
						@return false;
					}
				}
				@return $value;
			} @else {
				$idx : index($type, $value);
				@if not $idx {
					@if not $check-only {
						@error('The property "#{$property}" or the mixin/function "#{$method}" has to be one of these values "#{$type}" and not "#{$value}"');
					}
					@return false;
				}
				$v : nth($type, $idx);
				@if type-of($v) == type-of($value) {
					@if type-of($v) == number {
						@if unit($v) == unit($value) {
							@if not $check-only {
								@error('The property "#{$property}" or the mixin/function "#{$method}" has to be one of these values "#{$type}" and not "#{$value}"');
							}
							@return $value;
						} @else {
							@return false;
						}
					} @else {
						@return $value;
					}
				} @else {
					@if not $check-only {
						@error('The property "#{$property}" or the mixin/function "#{$method}" has to be one of these values "#{$type}" and not "#{$value}"');
					}
					@return false;
				}
				@return $value;
			}
		}
	} @else {
		@return $value;
	}
	@if not $check-only {
		@error('The property "#{$property}" or the mixin/function "#{$method}" is wrong');
	}
	@return false;

}

$_s_nested_properties : ();
$_s_nested_properties_depth : ();
@function s-handle-nested(
	$name,
	$map
) {
	@if map-get($_s_nested_properties, $name) {
		$map : map-merge(map-get($_s_nested_properties, $name), $map);
	} @else {
		$_s_nested_properties : map-set($_s_nested_properties, $name, $map) !global;
	}
	@return $map;
}
@mixin s-handle-nested(
	$args...
) {
	@each $arg in $args {
		$name : $arg;
		// up depth
		$depth : map-get($_s_nested_properties_depth, $name);
		@if $depth == null or $depth == 0 {
			$depth : 1;
		} @else {
			$depth : $depth + 1;
		}
		
		$_s_nested_properties_depth : map-set($_s_nested_properties_depth, $name, $depth) !global;
	}

	@content;

	@each $arg in $args {
		$name : $arg;
		$reset : false;
		$depth : map-get($_s_nested_properties_depth, $name);
		$depth : $depth - 1;
		$_s_nested_properties_depth : map-set($_s_nested_properties_depth, $name, $depth) !global;
		@if $depth <= 0 {
			$reset : true;
		}
		@if $reset {
			$_s_nested_properties : map-set($_s_nested_properties, $name, null) !global;
		}
	}

	
}

//
// Parse properties
//
@function s-parse-properties(
	$properties,
	$keywords,
	$aliases : ()
) {

	// default aliases
	$aliases : map-merge($aliases, (
		width : w,
		height : h,
		color : c,
		top : t,
		right : r,
		bottom : b,
		left : l
	));

	// check if is a map or a list
	@if type-of($properties) == map {
		$new-map : ();

		// loop on each properties to 
		@each $prop, $value in $properties {

			// get the real name
			$prop : _s-get-property-name($prop, $keywords, $aliases);

			// if we have a property
			@if $prop {

				// get the type
				$type : _s-get-property-type($prop, $keywords, $aliases);

				// if we have found, check the type
				@if $type {
					
					// check the property type with the value
					@if _s-check-property($prop, $type, $value) {
						$new-map : map-set($new-map, $prop, $value);
					}

				}
			}
		}

		// return new map
		@return $new-map;

	} @else {

		$map : ();
		$values : ();
		$current_prop : null;
		$first : true;
		@each $prop in $properties {
			
			@if type-of($prop) == string and str-slice($prop,1,1) == '-' {
				
				// remove the - at property beginning
				$prop : str-slice($prop, 2);

				// get the real name
				$prop : _s-get-property-name($prop, $keywords, $aliases);

				// we have a new property
				// need to check if we have already one in memory
				// to save it in the map after checking the type
				@if $current_prop {
					@if length($values) == 0 {
						$values : true
					} @else if length($values) == 1 and type-of($values) == list {
						$values : nth($values, 1);
					}
					$type : _s-get-property-type($current_prop, $keywords, $aliases);
					
					// check the property type with the value
					@if _s-check-property($prop, $type, $values) {
						$map : map-set($map, $current_prop, $values);
					}
				}
				$first : false;
				@if $prop {
					$current_prop : $prop;
					$values : ();
				}
				
			} @else {

				@if $first {
					// check if the type is ok
					$found : false;
					@each $name, $type in $keywords {
						
						@if $found == false {
							
							@if _s-check-property($name, $type, $prop, true) {
								$map : map-set($map, $name, $prop);
								$keywords : map-remove($keywords, $name);
								$found : true;
							}
						}
					}
				} @else {
					$values : append($values, $prop);
				}

				@if $current_prop {
					@if length($values) == 0 {
						$values : true
					} @else if length($values) == 1 and type-of($values) == list {
						$values : nth($values, 1);
					}	
					$type : _s-get-property-type($current_prop, $keywords, $aliases);

					// check the property type with the value
					@if _s-check-property($current_prop, $type, $values) {
						$map : map-set($map, $current_prop, $values);
					}
				}
			}
		}
		@if $current_prop {
			@if length($values) == 0 {
				$values : true
			} @else if length($values) == 1 and type-of($values) == list {
				$values : nth($values, 1);
			}	
			$type : _s-get-property-type($current_prop, $keywords, $aliases);
			
			// check the property type with the value
			@if _s-check-property($current_prop, $type, $values) {
				$map : map-set($map, $current_prop, $values);
			}
		}

		// return map
		@return $map;

	}
}

@function _s-check-property(
	$property,
	$type,
	$value,
	$check-only : false
) {
	$required : false;
	// check if is a map
	@if type-of($type) == map {
		$type : map-get($type, type);
		$required : map-get-or($type, required, $required);
	}

	// check required
	@if $required and not $value {
		@error('The property #{$property} is required...');
	}

	// if not value, return false
	@if not $value {
		@return false;
	}

	// check explicit values
	@if type-of($type) == string {
		// check the type
		@if not s-is($value, $type) {
			@if $check-only {
				@return false;
			}
			@error('The property "#{$property}" need to be a "#{$type}" but it seems that you pass a "#{type-of($value)}" : #{$value}...');
		}
		@return true;
	} @else if type-of($type) == list {
		// check if the passed value exist in possible values
		@if type-of($value) == list and index($type, length) {
			@return true;
		} @else if type-of($value) == number and index($type, length) {
			@return true;
		} @else {

			// if its a list of values, check each values
			@if type-of($value) == list {
				@each $v in $value {
					@if not _s-check-property($property, $type, $v, true) {
						@return false;
					}
				}
				@return true;
			} @else {
				$idx : index($type, $value);
				@if not $idx {
					@return false;
				}
				$v : nth($type, $idx);
				@if type-of($v) == type-of($value) {
					@if type-of($v) == number {
						@if unit($v) == unit($value) {
							@return true;
						} @else {
							@return false;
						}
					} @else {
						@return true;
					}
				} @else {
					@return false;
				}
				@return true;
			}
		}
	} @else {
		@return true;
	}
	@return false;
}

@function _s-get-property-name(
	$property,
	$keywords : (),
	$aliases : ()
) {
	@if not $keywords {
		$keywords : ();
	}
	@if not $aliases {
		$aliases : ();
	}

	// check if exist
	$type : map-get($keywords, $property);
	// if we have a type, mean a property names like this
	// exist, return it
	@if $type {
		@return $property;
	}

	// if not in keywords, try to get the alias
	@if not $type {
		$alias_found : false;
		@each $alias_prop, $alias in $aliases {
			$al : index($alias, $property);
			@if $al {
				@return $alias_prop;
			}
		}
	}

	// nothing found
	@return null;
}

@function _s-get-property-type(
	$property,
	$keywords : (),
	$aliases : ()
) {
	@if not $keywords {
		$keywords : ();
	}
	@if not $aliases {
		$aliases : ();
	}

	// check if exist
	$type : map-get($keywords, $property);

	// if not in keywords, try to get the alias
	@if not $type {
		$alias_found : false;
		@each $alias_prop, $alias in $aliases {
			@if $alias_found == false {
				$al : index($alias, $property);
				@if $al or type-of($alias) == string and $property == $alias {
					$alias_found : true;
					$property : $alias_prop;
				}
			}
		}
		// check again if now we have a property like this
		$type : map-get($keywords, $property);
	}
	// return the type
	@return $type;
}